---
layout: post
title:  "Welcome to Jekyll!"
date:   2015-09-15 00:29:03
categories: misc
---

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.11 (454874)"/><meta name="author" content="anand_vc_com@yahoo.com"/><meta name="created" content="2019-04-01 05:25:53 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2019-04-02 03:54:12 +0000"/><title>Disjoint Set Data Structure</title></head><body><div>Let S be the set of all elements and R be the relation defined on it. So, for every pair of elements in a,b E S, a R b is either true or false. If it is true, we say that a and b are related, otherwise they are not related. A relation R is called an equivalence relation if it satisfies the following properties:</div><div><br/></div><ol><li>Reflexive - for every element a E S, a R a is true.</li><li>Symmetric - for any two elements a,b E S, if a R b is true then b R a is true.</li><li>Transitive - for any three elements a,b,c E S, if  a R b and b R c is true then a R c is true.</li></ol><div><br/></div><div><b>Examples of non-equivalence relations</b></div><div><ol><li>S = { students in a class }, R = “is friend of”</li><ul><li>Transitive property does not hold true here. If Nandan is friend of Adarsh and Adarsh is friend of karan, that does not mean that Nandan and Karan are also friends. They might or might not be friends.<br/></li></ul><li>S = { people in a wedding }, R = “knows”</li><ul><li>Symmetric property does not hold true here. I and Mukesh Ambani attends same wedding. I know Mukesh Ambani but he does not know me.</li></ul></ol></div><div><br/></div><div><b>Examples of equivalence relations</b></div><div><ol><li>S = { people in the world }, R = “is in same country”.</li><li>S = { cities in a state }, R = “is connected to”.</li><li>S = { students in a class }, R = “is sibling of”.</li></ol></div><div><br/></div><div>When you have equivalence relation, the set of all elements gets partitioned into number of disjoint (non-overlapping) sets called equivalence classes. Because of transitive property of equivalence relation, there exist equivalence classes which partitions all elements into multiple disjoint sets.</div><div><br/></div><div>If S1, S2, ….,Sn are equivalence classes of elements of set S, then following are some properties of equivalence classes:</div><div><br/></div><ol><li>S = S1 U S2 U…….. U Sn (each element belongs to only one class)</li><li>null = S1 intersection S2 intersection ….. intersection Sn (because equivalence classes are non-overlapping)</li></ol><div><br/></div><div>Since the intersection of two equivalence classes is empty, the equivalence classes are sometimes called disjoint sets.To decide if a R b, we just need to check whether a and b are in the same equivalence class or not.</div><div><br/></div><div>In computer science, a disjoint set data structure is a data structure that tracks a set of elements partitioned into a number of disjoint (non-overlapping) subsets - <span style="font-weight: bold;">Wikipedia</span>.</div><div><br/></div><div> Equivalence classes can be implemented using disjoint sets data structure. Usually, there is a need to perform following operations on disjoint sets data structure:</div><div><br/></div><ol><li>There is a need to merge two disjoint sets into one because of transitive property. This is also called as “Union” or “Merge”</li><li>Find the disjoint set to which an element belongs to. This is also called as “Find”. </li></ol><div><br/></div><div>“Union-Find” and “Merge-Find” are another names for disjoint set data structure. Disjoint set data structure can be used to solve many problems where there is a concept of equivalence relation and equivalence classes.</div><div><br/></div><div><span style="font-weight: bold;">API for UnionFind</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">class UnionFind {</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    public void union(int i, int j); //merges the disjoint set of i with disjoint set of j</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    public int find(int i); //returns the disjoint set of i</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">}</span></div><div><br/></div><div><span style="font-style: italic; font-weight: bold;">Conceptual</span></div><table style="width: 100%; border-collapse: collapse; table-layout: fixed;"><tbody><tr><td style="width: 33.333333333333336%; border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px; min-width: 33.333333333333336%;"><div style="text-align: center;"><span style="font-weight: bold;">Invocation</span></div></td><td style="width: 33.333333333333336%; border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px; min-width: 33.333333333333336%;"><div style="text-align: center;"><span style="font-weight: bold;">State</span></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>-</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>{1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>union(3,9)</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>{1}, {2}, {3, 9}, {4}, {5}, {6}, {7}, {8}, {10}</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>union(1,4)</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>{1, 4}, {2}, {3, 9}, {5}, {6}, {7}, {8}, {10}</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>union(4,2)</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>S1={1, 4, 2}, S2={3, 9}, S3={5}, S4={6}, S5={7}, S6={8}, S7={10}</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>find(2)</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>S1</div></td></tr></tbody></table><div><br/></div><div><span style="font-weight: bold;">UnionFind - Array Based Implementation (aka quick find)</span></div><div>In this, an array of size n is initialized using a[i] = i, where i=1,2,3,…,n. Each element starts in its own disjoint sets. The sets keep on merging due to union operation.</div><div><br/></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">class UnionFind {</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    private int arr[];</span></div><div><br/></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    public UnionFind(int n) {</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    //Start with n disjoint sets. Each element belongs to a separate disjoint set</span></div><div><font color="#942192"><i>        //a[0] is a waste. We want to avoid mistakes that can occur while calculating subscripts.</i></font><br/></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    arr = new int[n+1];</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    for (int i = 0; i &lt;= n; i++)</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    arr[i] = i;</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    }</span></div><div><br/></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    //O(n) - as it iterates over the array</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    public void union(int i, int j) {</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    int iSet = find(i); //find the set to which i belongs</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    int jSet = find(j); //find the set to which j belongs</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    if (iSet == jSet)</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    return;</span></div><div><br/></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    for (int a = 1; a &lt; arr.length; a++)</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    {</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    //Elements which are in the set of i, change them to the set of j,</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    //giving a feeling of merge operation</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    if (arr[i] == iSet)</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    arr[i] = jSet;</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    }</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    }</span></div><div><br/></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    //O(1)</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    public int find(int i)</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    {</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    </span><span style="font-style: italic; color: rgb(148, 33, 146);">    return arr[i];</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">    }</span></div><div><span style="font-style: italic; color: rgb(148, 33, 146);">}</span></div><div><br/></div><div><span style="font-style: italic; font-weight: bold;">Above Algorithm</span></div><table style="width: 100%; border-collapse: collapse; table-layout: fixed;"><tbody><tr><td style="width: 33.333333333333336%; border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px; min-width: 33.333333333333336%;"><div><span style="font-weight: bold;">Invocation</span></div></td><td style="width: 33.333333333333336%; border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px; min-width: 33.333333333333336%;"><div style="text-align: center;"><span style="font-weight: bold;">State</span></div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>-</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>arr index = 0 1 2 3 4 5 6 7 8 9 10 (n = 10)</div><div>arr value = 0 1 2 3 4 5 6 7 8 9 10</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>union(3,9)</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>arr index = 0 1 2 <font color="#ff40ff">3</font> 4 5 6 7 8 9 10</div><div>arr value = 0 1 2 <font color="#ff40ff">9</font> 4 5 6 7 8 9 10</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>union(1,4)</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>arr index = 0 <font color="#ff40ff">1</font> 2 3 4 5 6 7 8 9 10</div><div>arr value = 0 <font color="#ff40ff">4</font> 2 9 4 5 6 7 8 9 10</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>union(4,2)</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>arr index = 0 <font color="#ff40ff">1</font> 2 3 <font color="#ff40ff">4</font> 5 6 7 8 9 10</div><div>arr value = 0 <font color="#ff40ff">2</font> 2 9<font color="#ff40ff"> 2</font> 5 6 7 8 9 10</div></td></tr><tr><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>find(2)</div></td><td style="border: 1px solid rgb(219, 219, 219); padding: 10px; margin: 0px;"><div>2</div></td></tr></tbody></table><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Quick-Union - Forest based implementation using Arrays</span></div><div><br/></div></body></html>
